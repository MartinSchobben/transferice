---
title: "model-types"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{model-types}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(transferice)
```

# Data

For a starters we use again all dinocyst data but exclusively use temperature at a 30 meter water depth as an outcome variable.


```{r splits}
library(recipes)
library(rsample)
library(dplyr)
# we take a subset as these models are more demanding
# splitting
dinodat_split <- initial_split(slice_sample(dinodat, n = 900), prop = 0.75)
# training
dinodat_train <- training(dinodat_split)
# testing
dinodat_test <- testing(dinodat_split)

# variables
vars <- role_organizer(dinodat, "t_an")
# taxa
txa <- vars[names(vars) == "predictor"]
# new names
new <- paste0("taxa_", seq_along(txa))

# recipe
rcp <- recipe(x = dinodat, vars = vars, roles = names(vars)) |> 
   # rescale outcomes
  step_normalize(all_outcomes()) |> 
  # rename taxa
  step_rename(!!!rlang::set_names(txa, new)) |> 
  # rescale predictor
  step_logit(dplyr::any_of(new), offset = 0.025) |> 
  # center predictors
  step_center(dplyr::any_of(new)) |> 
  # reduce dimensions
  step_pca(dplyr::any_of(new), num_comp = tune::tune()) |> 
  # remove location that lie close to each other
  step_zerogeodist(lon = longitude, lat = latitude, skip = TRUE) |> 
  # update spatial to predictor
  recipes::update_role(longitude, latitude, new_role = "predictor")

```


```{r}
library(nlme)
library(parsnip)
library(multilevelmod)

# model
gls_spec <- linear_reg() |> 
  set_engine(
    "gls",  
    control = nlme::lmeControl(opt = 'optim'),
    correlation = nlme::corSpatial(form = ~longitude + latitude, type = "g" )
  )  |> 
  # usage of the model for regression
  set_mode('regression')
```


# Workflow


```{r workflow}
library(workflows)
library(tune)
library(yardstick)

# workflow
gls_wfl <- workflow() |> 
  add_recipe(rcp) |> 
  add_model(gls_spec) 

# multiple cross validation
dinodat_cv <- vfold_cv(training(dinodat_split), v = 10)

# tuning grid
tune_grid <- dials::grid_regular(tune::extract_parameter_set_dials(gls_wfl), levels = 4)

# tuning
dinodat_tune <- tune::tune_grid(
  gls_wfl,
  resamples = dinodat_cv,
  grid = tune_grid,
  metrics = yardstick::metric_set(yardstick::rmse), 
  control = ctrl
)

```

```{r out}
library(ggplot2)
collect_metrics(dinodat_tune, summarize = FALSE) |> 
  filter(.estimate < 100) |>
  ggplot(aes(x = num_comp, y = .estimate, group = num_comp)) +
  geom_boxplot()
```

partial plots
 
```{r partial, options}
ggpartial(dinodat_tune, gls_wfl, tune = 1, out = "t_an", id = "test", plot_type = "static")
```


# Mixed effect

```{r mix}
# random formula
rand <- formula_parser(dinodat_prep, "t_an", aliases = "PC", type = "random")
lme_spec <- parsnip::linear_reg() |> 
  parsnip::set_engine(
    "lme", 
    random = ~PC1 + PC2|parameter, 
    correlation = corSpatial(form = ~longitude + latitude|parameter, type = "g" )
  )
```