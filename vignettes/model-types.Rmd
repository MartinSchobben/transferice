---
title: "model-types"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{model-types}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(transferice)
```

# Data

For a starters we use again all dinocyst data but exclusively use temperature at a 30 meter water depth as an outcome variable.


```{r splits}
library(recipes)
library(rsample)
# splitting
dinodat_split <- initial_split(dinodat, prop = 0.75)# strata = "parameter") 
# training
dinodat_train <- training(dinodat_split)
# testing
dinodat_test <- testing(dinodat_split)

# variables
vars <- role_organizer(dinodat, "t_an")
# taxa
txa <- vars[names(vars) == "predictor"]

# recipe
rcp <- recipe(x = dinodat, vars = vars, roles = names(vars)) |> 
   # rescale outcomes
  step_normalize(all_outcomes()) |> 
  # rename taxa
  step_rename(!!!rlang::set_names(txa, paste0("taxa_", seq_along(txa)))) |> 
  # rescale predictor
  step_logit(all_predictors(), offset = 0.025) |> 
  # center predictors
  step_center(all_predictors()) |> 
  # reduce dimensions
  step_pca(all_predictors(), num_comp = 4) 

```


```{r}
library(nlme)
library(parsnip)
library(multilevelmod)

# prep data
dinodat_prep <- prep(rcp, training = dinodat_train) |> bake(new_data= NULL)
# fixed form
fixed <- formula_parser(dinodat_prep, "t_an", aliases = "PC")

# model
gls_spec <- linear_reg() |> 
  set_engine(
    "gls",  
    control = lmeControl(opt = 'optim')
  )  |> 
  # usage of the model for regression
  set_mode('regression')

gls_fit <- gls_spec |> 
 fit(fixed, data = dinodat_prep)

```


# Workflow


```{r workflow}
library(workflows)
library(tune)
library(yardstick)

gls_wfl <- workflow() |> 
  add_recipe(rcp) |> 
  add_model(gls_spec, formula = fixed) 

gls_fit <- last_fit(gls_wfl, dinodat_split)

# multiple cross validation
dinodat_cv <- vfold_cv(training(dinodat_split), v = 10)

dinodat_resamp <- fit_resamples(
  gls_wfl, 
  resamples = dinodat_cv,  
  metrics = metric_set(rmse), 
  control = ctrl
)
```


partial plots
 
```{r partial, options}
ggpartial(dinodat_resamp, gls_wfl, pred = "PC1", out = "t_an", id = "test", plot_type = "static")
```


# spatial variance

```{r spat}
library(dplyr)
# complex execution take smaller sample
dinodat_prep_sm <- slice_sample(dinodat_prep, 100)

# update recipe
rcp <- rcp |> 
  step_zerogeodist(lon = longitude, lat = latitude)

# prep data
dinodat_prep_sm <- prep(rcp, training = dinodat_train) |> bake(new_data= NULL)
# correlation structure
corr <- formula_parser(dinodat_prep_sm, "t_an", aliases = "PC", type = "correlation")

# model with spatial correlation
gls_xy_spec <- linear_reg() |> 
  set_engine(
    "gls",  
    control = lmeControl(opt = 'optim'),
    correlation = corSpatial(form = ~corr, type = "g" )
  )  |> 
  # usage of the model for regression
  set_mode('regression')

gls_xy_fit <- gls_xy_spec |> 
 fit(fixed, data = dinodat_prep_sm)
```


# Mixed effect

```{r mix}
# random formula
rand <- formula_parser(dinodat_prep, "t_an", aliases = "PC", type = "random")
lme_spec <- parsnip::linear_reg() |> 
  parsnip::set_engine(
    "lme", 
    random = ~PC1 + PC2|parameter, 
    correlation = corSpatial(form = ~longitude + latitude|parameter, type = "g" )
  )
```